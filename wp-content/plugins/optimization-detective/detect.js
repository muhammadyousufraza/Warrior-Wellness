const win=window,doc=win.document,consoleLogPrefix="[Optimization Detective]",storageLockTimeSessionKey="odStorageLockTime";function isStorageLocked(e,t){if(0===t)return!1;try{const o=parseInt(sessionStorage.getItem(storageLockTimeSessionKey));return!isNaN(o)&&e<o+1e3*t}catch(e){return!1}}function setStorageLock(e){try{sessionStorage.setItem(storageLockTimeSessionKey,String(e))}catch(e){}}function log(...e){console.log(consoleLogPrefix,...e)}function warn(...e){console.warn(consoleLogPrefix,...e)}function error(...e){console.error(consoleLogPrefix,...e)}function isViewportNeeded(e,t){let o=!1;for(const{minimumViewportWidth:n,complete:i}of t){if(!(e>=n))break;o=!i}return o}function getCurrentTime(){return Date.now()}export default async function detect({serveTime:e,detectionTimeWindow:t,isDebug:o,restApiEndpoint:n,restApiNonce:i,currentUrl:r,urlMetricsSlug:s,urlMetricsNonce:c,urlMetricsGroupStatuses:a,storageLockTTL:d,webVitalsLibrarySrc:l,urlMetricsGroupCollection:u}){const g=getCurrentTime();if(o&&log("Stored URL metrics group collection:",u),g-e>t)return void(o&&warn("Aborted detection due to being outside detection time window."));if(!isViewportNeeded(win.innerWidth,a))return void(o&&log("No need for URL metrics from the current viewport."));if(await new Promise((e=>{"loading"!==doc.readyState?e():doc.addEventListener("DOMContentLoaded",e,{once:!0})})),await new Promise((e=>{"complete"===doc.readyState?e():win.addEventListener("load",e,{once:!0})})),"function"==typeof requestIdleCallback&&await new Promise((e=>{requestIdleCallback(e)})),isStorageLocked(g,d))return void(o&&warn("Aborted detection due to storage being locked."));if(doc.documentElement.scrollTop>0)return void(o&&warn("Aborted detection since initial scroll position of page is not at the top."));o&&log("Proceeding with detection");const w=doc.body.querySelectorAll("[data-od-xpath]"),m=new Map([...w].map((e=>[e,e.dataset.odXpath]))),f=[];let p;function h(){p instanceof IntersectionObserver&&(p.disconnect(),win.removeEventListener("scroll",h))}m.size>0&&(await new Promise((e=>{p=new IntersectionObserver((t=>{for(const e of t)f.push(e);e()}),{root:null,threshold:0});for(const e of m.keys())p.observe(e)})),win.addEventListener("scroll",h,{once:!0,passive:!0}));const{onLCP:L}=await import(l),S=[];await new Promise((e=>{L((t=>{S.push(t),e()}),{reportAllChanges:!0})})),h(),o&&log("Detection is stopping.");const b={url:r,slug:s,nonce:c,viewport:{width:win.innerWidth,height:win.innerHeight},elements:[]},v=S.at(-1);for(const e of f){const t=m.get(e.target);if(!t){o&&error("Unable to look up XPath for element");continue}const n={isLCP:e.target===v?.entries[0]?.element,isLCPCandidate:!!S.find((t=>t.entries[0]?.element===e.target)),xpath:t,intersectionRatio:e.intersectionRatio,intersectionRect:e.intersectionRect,boundingClientRect:e.boundingClientRect};b.elements.push(n)}o&&log("Current URL metrics:",b),await new Promise((e=>{setTimeout(e,0)}));try{const e=await fetch(n,{method:"POST",headers:{"Content-Type":"application/json","X-WP-Nonce":i},body:JSON.stringify(b)});if(200===e.status&&setStorageLock(getCurrentTime()),o){const t=await e.json();200===e.status?log("Response:",t):error("Failure:",t)}}catch(e){o&&error(e)}m.clear()}